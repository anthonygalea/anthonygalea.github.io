<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>Solutions to 4Clojure Easy Problems</title>

  <link href="https://www.anthony-galea.com/favicon.png" rel="icon">

  <style media="screen">
    .navbar,.navbar>.container>.title{position:fixed}.links,time{float:right}.label,abbr,dt{font-weight:700}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}body,html{margin:0;padding:0}html{font-family:Lato,Helvetica,Arial,sans-serif;font-size:16px;line-height:1.25}body{color:#515151;background-color:#fff;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}.olist,.paragraph,.post-date,.pygments,.quoteblock,.ulist,h1,h2,h3{max-width:56rem;margin:auto}.paragraph{margin-top:2rem;margin-bottom:2rem}p,pre{margin-top:0;margin-bottom:1rem}.post-footer,.post-header{background-color:#f9f9f9;padding-top:2rem;padding-bottom:1.5rem}.post-footer ul{line-height:1.5rem}.navbar{margin-right:0;margin-left:0;background-color:#337ab7;height:3rem;width:100%;z-index:100}code,pre,tbody tr:nth-child(odd) td,tbody tr:nth-child(odd) th{background-color:#f9f9f9}.navbar a{color:#fff;text-decoration:none!important}.links ul{list-style-type:none;font-size:1.5rem;line-height:3rem}.navbar h1{color:#fff;margin-top:0;font-size:1.1rem;line-height:3rem}h1,h2,h4,h5,h6{margin-top:2rem}a{color:#337ab7;text-decoration:none}a:focus,a:hover{text-decoration:underline}h1,h2,h3,h4,h5,h6{font-weight:700;line-height:1.25;color:#2b2b2b;text-rendering:optimizeLegibility}h1{font-size:2rem}h2{font-size:1.5rem}h3{margin-top:1.5rem;font-size:1.25rem}h4,h5,h6{font-size:1rem}abbr,code{font-size:85%}strong{color:#303030}dl,ol,ul{margin-top:0}dd{margin-bottom:.5rem}hr{position:relative;margin:.5rem 0;border:0;border-top:1px solid #eee;border-bottom:1px solid #fff}abbr{color:#555;text-transform:uppercase}abbr[title]{cursor:help;border-bottom:1px dotted #e5e5e5}code,pre{font-family:Menlo,Monaco,"Courier New",monospace}code{padding:.25em .5em;color:#bf616a;border-radius:3px}pre{display:block;font-size:.8rem;line-height:1.4;white-space:pre;white-space:pre-wrap}pre code{padding:0;font-size:90%;color:inherit;background-color:transparent}.highlight{margin:auto;border-radius:4px;max-width:56rem}.highlight pre,blockquote p:last-child{margin-bottom:0}blockquote{margin:.8rem 0;color:#7a7a7a;border-left:.25rem solid #e5e5e5}@media (max-width:38em){a.label,time{display:none}}@media (min-width:30em){blockquote{padding-right:0;padding-left:1.25rem}}blockquote .paragraph{padding-top:1rem;padding-bottom:1rem}img{display:block;max-width:100%;margin:auto;border-radius:5px}table,td,th{border:1px solid #e5e5e5}table{margin:auto auto 1rem;border-collapse:collapse}td,th{padding:.25rem .5rem}.container{max-width:56rem;margin-left:auto;margin-right:auto}.page-title,.post-title,.post-title a{color:#2b2b2b}.page-title,.post-title{margin-top:-.6rem}.post-date{display:block;color:#9a9a9a}@media (min-width:48em){html{font-size:16px}}@media (min-width:58em){html{font-size:20px}}.content{padding-top:3rem;margin:0 auto}.posts{margin-bottom:2rem;list-style:none;margin-left:-2rem;max-width:60rem;font-size:.9rem;line-height:1.5rem;padding-top:2rem}.post p{margin:0;text-align:justify}.imageblock,.imageblock>.title,.label{text-align:center}pre{padding:0}.imageblock>.content,.listingblock>.content{margin:auto;padding-top:0;padding-bottom:0}.listingblock>.content{padding-top:.75rem;padding-bottom:.75rem;background-color:#272822}.label,.post .label{background-color:#337ab7;color:#fff}.label{display:inline;padding:.2em .6em .3em;font-size:75%;line-height:1;white-space:nowrap;vertical-align:baseline;border-radius:.25em;margin:0 .25em}a.label:focus,a.label:hover{color:#fff;text-decoration:none;cursor:pointer}.label:empty{display:none}.post-date a.label,.posts a.label{color:#fff;text-decoration:none;cursor:pointer}.tableblock .MathJax_Display,.tableblock p{margin:0}canvas{display:inline-block;margin:20px}
  </style>

  
  
  
  

  <meta name="description" content="">
  <meta name="keywords" content="4clojure,easy,solutions,problems,clojure">
  

  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-38752250-1', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>
<body>

<div class="navbar">
  <div class="container">
  <div class="title">
    <h1><a href="/">Anthony Galea</a></h1>
  </div>
  <div class="links">
    <ul>
      <li>
      <a href="https://twitter.com/anthonygalea" target="_blank"><i class="icon-twitter-squared"></i></a>
      <a href="https://github.com/anthonygalea" target="_blank"><i class="icon-github-squared"></i></a>
      
      
      <a href="https://www.linkedin.com/in/anthonygalea" target="_blank"><i class="icon-linkedin-squared"></i></a>
      
      
      
      <a href="mailto:anthony.galea@gmail.com" target="_blank"><i class="icon-mail-squared"></i></a>
      <a href="https://www.anthony-galea.com/index.xml" type="application/rss+xml" target="_blank"><i class="icon-rss-squared"></i></a>
      </li>
    </ul>
  </div>
</div>
</div>



<div class="content">
  <div class="post">
    <div class="post-header">
      <h1 class="post-title">Solutions to 4Clojure Easy Problems</h1>
      <span class="post-date">
      Mar 29, 2016 &middot; 22 minute read
      
      <a class="label" href="https://www.anthony-galea.com/categories/clojure">clojure</a><a class="label" href="https://www.anthony-galea.com/categories/interactive">interactive</a>
      

      
      </span>
    </div>
    <div class="paragraph">
<p>Following the first post on solutions to <a href="http://www.4clojure.com">4Clojure</a> problems, in this post I will continue with the next set of problems. Once again all solutions are on <a href="https://github.com/anthonygalea/solutions-4clojure">GitHub</a>, and if you have any suggestions/alternative solutions I would love to hear from you.</p>
</div>
<div class="sect1">
<h2 id="_19_last_element">19. Last Element</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which returns the last element in a sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn last-element [s]
  (nth s (dec (count s))))

[(= (last-element [1 2 3 4 5]) 5)
 (= (last-element '(5 4 3)) 3)
 (= (last-element ["b" "c" "d"]) "d")]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_20_penultimate_element">20. Penultimate Element</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which returns the second to last element from a sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn penultimate-element [s]
  (nth s (- (count s) 2)))

[(= (penultimate-element (list 1 2 3 4 5)) 4)
 (= (penultimate-element ["a" "b" "c"]) "b")
 (= (penultimate-element [[1 2] [3 4]]) [1 2])]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_21_nth_element">21. Nth Element</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which returns the Nth element from a sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn nth-element [s n]
  (last (take (inc n) s)))

[(= (nth-element '(4 5 6 7) 2) 6)
 (= (nth-element [:a :b :c] 0) :a)
 (= (nth-element [1 2 3 4] 1) 2)
 (= (nth-element '([1 2] [3 4] [5 6]) 2) [5 6])]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_22_count_a_sequence">22. Count a Sequence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which returns the total number of elements in a sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn count-a-sequence [s]
  (reduce (fn [c _] (inc c)) 0 s))

[(= (count-a-sequence '(1 2 3 3 1)) 5)
 (= (count-a-sequence "Hello World") 11)
 (= (count-a-sequence [[1 2] [3 4] [5 6]]) 3)
 (= (count-a-sequence '(13)) 1)
 (= (count-a-sequence '(:a :b :c)) 3)]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_23_reverse_a_sequence">23. Reverse a Sequence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which reverses a sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn reverse-a-sequence [s]
  (reduce #(cons %2 %1) '() s))

[(= (reverse-a-sequence [1 2 3 4 5]) [5 4 3 2 1])
 (= (reverse-a-sequence (sorted-set 5 7 2 7)) '(7 5 2))
 (= (reverse-a-sequence [[1 2][3 4][5 6]]) [[5 6][3 4][1 2]])]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_sum_it_all_up">24. Sum It All Up</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which returns the sum of a sequence of numbers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn sum-it-all-up [s]
  (reduce + s))

[(= (sum-it-all-up [1 2 3]) 6)
 (= (sum-it-all-up (list 0 -2 5 5)) 8)
 (= (sum-it-all-up #{4 2 1}) 7)
 (= (sum-it-all-up '(0 0 -1)) -1)
 (= (sum-it-all-up '(1 10 3)) 14)]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_25_find_the_odd_numbers">25. Find the odd numbers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which returns only the odd numbers from a sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn find-the-odd-numbers [s]
  (filter odd? s))

[(= (find-the-odd-numbers #{1 2 3 4 5}) '(1 3 5))
 (= (find-the-odd-numbers [4 2 1 6]) '(1))
 (= (find-the-odd-numbers [2 2 4 6]) '())
 (= (find-the-odd-numbers [1 1 1 3]) '(1 1 1 3))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_26_fibonacci_sequence">26. Fibonacci Sequence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which returns the first X fibonacci numbers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn fibonacci-sequence [n]
  (letfn [(fib [a b] (lazy-seq (cons b (fib b (+ a b)))))]
  (take n (fib 0 1))))

[(= (fibonacci-sequence 3) '(1 1 2))
 (= (fibonacci-sequence 6) '(1 1 2 3 5 8))
 (= (fibonacci-sequence 8) '(1 1 2 3 5 8 13 21))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_27_palindrome_detector">27. Palindrome Detector</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which returns <code>true</code> if the given sequence is a palindrome. Hint: "racecar" does not equal '(\r \a \c \e \c \a \r)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn palindrome-detector [s]
  (= (seq s) (reverse s)))

[(false? (palindrome-detector '(1 2 3 4 5)))
 (true? (palindrome-detector "racecar"))
 (true? (palindrome-detector [:foo :bar :foo]))
 (true? (palindrome-detector '(1 1 3 3 1 1)))
 (false? (palindrome-detector '(:a :b :c)))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_28_flatten_a_sequence">28. Flatten a Sequence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which flattens a sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn flatten-a-sequence [s]
  (reduce (fn myflatten [collection element]
            (if (sequential? element)
              (reduce myflatten collection element)
              (conj collection element))) [] s))

[(= (flatten-a-sequence '((1 2) 3 [4 [5 6]])) '(1 2 3 4 5 6))
 (= (flatten-a-sequence ["a" ["b"] "c"]) '("a" "b" "c"))
 (= (flatten-a-sequence '((((:a))))) '(:a))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_29_get_the_caps">29. Get the Caps</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which takes a string and returns a new string containing only the capital letters.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn get-the-caps [s]
  (apply str (re-seq #"[A-Z]+" s)))

[(= (get-the-caps "HeLlO, WoRlD!") "HLOWRD")
 (empty? (get-the-caps "nothing"))
 (= (get-the-caps "$#A(*&amp;987Zf") "AZ")]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_30_compress_a_sequence">30. Compress a Sequence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which removes consecutive duplicates from a sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn compress-a-sequence [s]
  (map #(first %) (partition-by identity s)))

[(= (apply str (compress-a-sequence "Leeeeeerrroyyy")) "Leroy")
 (= (compress-a-sequence [1 1 2 3 3 2 2 3]) '(1 2 3 2 3))
 (= (compress-a-sequence [[1 2] [1 2] [3 4] [1 2]]) '([1 2] [3 4] [1 2]))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_31_pack_a_sequence">31. Pack a Sequence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which packs consecutive duplicates into sub-lists.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn pack-a-sequence [s]
  (partition-by identity s))

[(= (pack-a-sequence [1 1 2 1 1 1 3 3]) '((1 1) (2) (1 1 1) (3 3)))
 (= (pack-a-sequence [:a :a :b :b :c]) '((:a :a) (:b :b) (:c)))
 (= (pack-a-sequence [[1 2] [1 2] [3 4]]) '(([1 2] [1 2]) ([3 4])))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_32_duplicate_a_sequence">32. Duplicate a Sequence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which duplicates each element of a sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn duplicate-a-sequence [s]
  (reduce #(conj (conj %1 %2) %2) [] s))

[(= (duplicate-a-sequence [1 2 3]) '(1 1 2 2 3 3))
 (= (duplicate-a-sequence [:a :a :b :b]) '(:a :a :a :a :b :b :b :b))
 (= (duplicate-a-sequence [[1 2] [3 4]]) '([1 2] [1 2] [3 4] [3 4]))
 (= (duplicate-a-sequence [[1 2] [3 4]]) '([1 2] [1 2] [3 4] [3 4]))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_33_replicate_a_sequence">33. Replicate a Sequence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which replicates each element of a sequence a variable number of times.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn replicate-a-sequence [s n]
  (apply concat (map #(repeat n %) s)))

[(= (replicate-a-sequence [1 2 3] 2) '(1 1 2 2 3 3))
 (= (replicate-a-sequence [:a :b] 4) '(:a :a :a :a :b :b :b :b))
 (= (replicate-a-sequence [4 5 6] 1) '(4 5 6))
 (= (replicate-a-sequence [[1 2] [3 4]] 2) '([1 2] [1 2] [3 4] [3 4]))
 (= (replicate-a-sequence [44 33] 2) [44 44 33 33])]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_34_implement_range">34. Implement range</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which creates a list of all integers in a given range.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn implement-range [start end]
  (take (- end start) (iterate inc start)))

[(= (implement-range 1 4) '(1 2 3))
 (= (implement-range -2 2) '(-2 -1 0 1))
 (= (implement-range 5 8) '(5 6 7))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_38_maximum_value">38. Maximum value</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which takes a variable number of parameters and returns the maximum value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn maximum-value [&amp; params]
  (reduce
    (fn [x y]
      (if (&lt; x y) y x))
    params))

[(= (maximum-value 1 8 3 4) 8)
 (= (maximum-value 30 20) 30)
 (= (maximum-value 45 67 11) 67)]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_39_interleave_two_seqs">39. Interleave Two Seqs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which takes two sequences and returns the first item from each, then the second item from each, then the third, etc.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn interleave-two-seqs [a b]
  (if (&lt;= (count a) (count b))
  (flatten (map-indexed (fn [index item] [item (nth b index)]) a))
  (flatten (map-indexed (fn [index item] [item (nth b index)]) (take (count b) a)))))

[(= (interleave-two-seqs [1 2 3] [:a :b :c]) '(1 :a 2 :b 3 :c))
 (= (interleave-two-seqs [1 2] [3 4 5 6]) '(1 3 2 4))
 (= (interleave-two-seqs [1 2 3 4] [5]) [1 5])
 (= (interleave-two-seqs [30 20] [25 15]) [30 25 20 15])]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_40_interpose_a_seq">40. Interpose a Seq</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which separates the items of a sequence by an arbitrary value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn interpose-a-seq [v s]
  (rest (mapcat #(list v %) s)))

[(= (interpose-a-seq 0 [1 2 3]) [1 0 2 0 3])
 (= (apply str (interpose-a-seq ", " ["one" "two" "three"])) "one, two, three")
 (= (interpose-a-seq :z [:a :b :c :d]) [:a :z :b :z :c :z :d])]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_41_drop_every_nth_item">41. Drop Every Nth Item</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which drops every Nth item from a sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn drop-every-nth-item [s n]
  (keep-indexed #(if (not= (mod %1 n) (dec n)) %2) s))

[(= (drop-every-nth-item [1 2 3 4 5 6 7 8] 3) [1 2 4 5 7 8])
 (= (drop-every-nth-item [:a :b :c :d :e :f] 2) [:a :c :e])
 (= (drop-every-nth-item [1 2 3 4 5 6] 4) [1 2 3 5 6])]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_42_factorial_fun">42. Factorial Fun</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which calculates factorials.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn factorial-fun [n]
  (reduce * (range 1 (+ n 1))))

[(= (factorial-fun 1) 1)
 (= (factorial-fun 3) 6)
 (= (factorial-fun 5) 120)
 (= (factorial-fun 8) 40320)]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_45_intro_to_iterate">45. Intro to Iterate</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The iterate function can be used to produce an infinite lazy sequence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(def intro-to-iterate [1 4 7 10 13])

[(= intro-to-iterate (take 5 (iterate #(+ 3 %) 1)))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_47_contain_yourself">47. Contain Yourself</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>contains?</code> function checks if a KEY is present in a given collection. This often leads beginner clojurians to use it incorrectly with numerically indexed collections like vectors and lists.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(def contain-yourself 4)

[(contains? #{4 5 6} contain-yourself)
 (contains? [1 1 1 1 1] contain-yourself)
 (contains? {4 :a 2 :b} contain-yourself)
 (not (contains? [1 2 4] contain-yourself))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_48_intro_to_some">48. Intro to some</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The some function takes a predicate function and a collection. It returns the first logical true value of (predicate x) where x is an item in the collection.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(def intro-to-some 6)

[(= intro-to-some (some #{2 7 6} [5 6 7 8]))
 (= intro-to-some (some #(when (even? %) %) [5 6 7 8]))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_49_split_a_sequence">49. Split a sequence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which will split a sequence into two parts. Do not use <code>split-at</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn split-a-sequence [n s]
  (list (take n s) (drop n s)))

[(= (split-a-sequence 3 [1 2 3 4 5 6]) [[1 2 3] [4 5 6]])
 (= (split-a-sequence 1 [:a :b :c :d]) [[:a] [:b :c :d]])
 (= (split-a-sequence 2 [[1 2] [3 4] [5 6]]) [[[1 2] [3 4]] [[5 6]]])]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_51_advanced_destructuring">51. Advanced Destructuring</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Here is an example of some more sophisticated destructuring.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(def advanced-destructuring [1 2 3 4 5])

[(= [1 2 [3 4 5] [1 2 3 4 5]] (let [[a b &amp; c :as d] advanced-destructuring] [a b c d]))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_61_map_construction">61. Map Construction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which takes a vector of keys and a vector of values and constructs a map from them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn map-construction [keys values]
  (apply assoc {} (interleave keys values)))

[(= (map-construction [:a :b :c] [1 2 3]) {:a 1, :b 2, :c 3})
 (= (map-construction [1 2 3 4] ["one" "two" "three"]) {1 "one", 2 "two", 3 "three"})
 (= (map-construction [:foo :bar] ["foo" "bar" "baz"]) {:foo "foo", :bar "bar"})]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_62_re_implement_iterate">62. Re-implement Iterate</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Given a side-effect free function f and an initial value x write a function which returns an infinite lazy sequence of x, (f x), (f (f x)), (f (f (f x))), etc.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn reimplement-iterate [f x]
  (cons x (lazy-seq (reimplement-iterate f (f x)))))

[(= (take 5 (reimplement-iterate #(* 2 %) 1)) [1 2 4 8 16])
 (= (take 100 (reimplement-iterate inc 0)) (take 100 (range)))
 (= (take 9 (reimplement-iterate #(inc (mod % 3)) 1)) (take 9 (cycle [1 2 3])))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_63_group_a_sequence">63. Group a Sequence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Given a function f and a sequence s, write a function which returns a map. The keys should be the values of f applied to each item in s. The value at each key should be a vector of corresponding items in the order they appear in s.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn group-a-sequence [f vals]
  (into {}
        (map #(vector (f (first %)) (vec %))
             (partition-by f (sort vals)))))

[(= (group-a-sequence #(&gt; % 5) [1 3 6 8]) {false [1 3], true [6 8]})
 (= (group-a-sequence #(apply / %) [[1 2] [2 4] [4 6] [3 6]])
    {1/2 [[1 2] [2 4] [3 6]], 2/3 [[4 6]]})
 (= (group-a-sequence count [[1] [1 2] [3] [1 2 3] [2 3]])
    {1 [[1] [3]], 2 [[1 2] [2 3]], 3 [[1 2 3]]})]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_66_greatest_common_divisor">66. Greatest Common Divisor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Given two integers, write a function which returns the greatest common divisor.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn greatest-common-divisor [a b]
  (if (= b 0)
    a
    (recur b (mod a b))))

[(= (greatest-common-divisor 2 4) 2)
 (= (greatest-common-divisor 10 5) 5)
 (= (greatest-common-divisor 5 7) 1)
 (= (greatest-common-divisor 1023 858) 33)]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_81_set_intersection">81. Set Intersection</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which returns the intersection of two sets. The intersection is the sub-set of items that each set has in common.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn set-intersection [a b]
  (set (filter a b)))

[(= (set-intersection #{0 1 2 3} #{2 3 4 5}) #{2 3})
 (= (set-intersection #{0 1 2} #{3 4 5}) #{})
 (= (set-intersection #{:a :b :c :d} #{:c :e :a :f :d}) #{:a :c :d})]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_83_a_half_truth">83. A Half-Truth</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which takes a variable number of booleans. Your function should return true if some of the parameters are true, but not all of the parameters are true. Otherwise your function should return false.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn a-half-truth [&amp; booleans]
  (= (set booleans) #{true false}))

[(= false (a-half-truth false false))
 (= true (a-half-truth true false))
 (= false (a-half-truth true))
 (= true (a-half-truth false true false))
 (= false (a-half-truth true true true))
 (= true (a-half-truth true true true false))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_88_symmetric_difference">88. Symmetric Difference</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which returns the symmetric difference of two sets. The symmetric difference is the set of items belonging to one but not both of the two sets.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(require 'clojure.set)
(defn symmetric-difference [a b]
  (clojure.set/difference
    (clojure.set/union a b)
    (clojure.set/intersection a b)))

[(= (symmetric-difference #{1 2 3 4 5 6} #{1 3 5 7}) #{2 4 6 7})
 (= (symmetric-difference #{:a :b :c} #{}) #{:a :b :c})
 (= (symmetric-difference #{} #{4 5 6}) #{4 5 6})
 (= (symmetric-difference #{[1 2] [2 3]} #{[2 3] [3 4]}) #{[1 2] [3 4]})]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_90_cartesian_product">90. Cartesian Product</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which calculates the Cartesian product of two sets.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn cartesian-product [a b]
  (into #{}
        (for [x a y b] (vector x y))))

[(= (cartesian-product #{"ace" "king" "queen"} #{"♠" "♥" "♦" "♣"})
    #{["ace"   "♠"] ["ace"   "♥"] ["ace"   "♦"] ["ace"   "♣"]
      ["king"  "♠"] ["king"  "♥"] ["king"  "♦"] ["king"  "♣"]
      ["queen" "♠"] ["queen" "♥"] ["queen" "♦"] ["queen" "♣"]})
 (= (cartesian-product #{1 2 3} #{4 5})
   #{[1 4] [2 4] [3 4] [1 5] [2 5] [3 5]})
 (= 300 (count (cartesian-product (into #{} (range 10))
                                  (into #{} (range 30)))))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_95_to_tree_or_not_to_tree">95. To Tree, or not to Tree</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a predicate which checks whether or not a given sequence represents a binary tree. Each node in the tree must have a value, a left child, and a right child.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn binary? [s]
  (and
    (sequential? s)
    (= (count s) 3)
    (let [ left (second s)
          right (last s)]
      (and
        (or
          (nil? left)
          (binary? left))
        (or
          (nil? right)
          (binary? right))))))

[(= (binary? '(:a (:b nil nil) nil))
    true)
 (= (binary? '(:a (:b nil nil)))
   false)
 (= (binary? [1 nil [2 [3 nil nil] [4 nil nil]]])
    true)
 (= (binary? [1 [2 nil nil] [3 nil nil] [4 nil nil]])
   false)
 (= (binary? [1 [2 [3 [4 nil nil] nil] nil] nil])
    true)
 (= (binary? [1 [2 [3 [4 false nil] nil] nil] nil])
   false)
 (= (binary? '(:a nil ()))
    false)]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_96_beauty_is_symmetry">96. Beauty is Symmetry</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let us define a binary tree as "symmetric" if the left half of the tree is the mirror image of the right half of the tree. Write a predicate to determine whether or not a given binary tree is symmetric. (see To Tree, or not to Tree for a reminder on the tree representation we&#8217;re using).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn beauty-is-symmetry [s]
  {:pre [(sequential? s)
        (= (count s) 3)]}
  (let [left (second s)
        right (last s)
        mirror (fn mirror [s] {:pre [(= (count s) 3)]}
                 (let [left (second s)
                       right (last s)]
                   (if (and (nil? left) (nil? right))
                     s
                     (list
                       (first s)
                       (if (sequential? right) (mirror right) right)
                       (if (sequential? left) (mirror left) left)))))]
    (=
      left
      (if (sequential? right)
        (mirror right)
        right))))

[(= (beauty-is-symmetry '(:a (:b nil nil) (:b nil nil))) true)
 (= (beauty-is-symmetry '(:a (:b nil nil) nil)) false)
 (= (beauty-is-symmetry '(:a (:b nil nil) (:c nil nil))) false)
 (= (beauty-is-symmetry [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]
                        [2 [3 nil [4 [6 nil nil] [5 nil nil]]] nil]])
    true)
 (= (beauty-is-symmetry [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]
                           [2 [3 nil [4 [5 nil nil] [6 nil nil]]] nil]])
   false)
 (= (beauty-is-symmetry [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]
                           [2 [3 nil [4 [6 nil nil] nil]] nil]])
    false)]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_97_pascal_s_triangle">97. Pascal&#8217;s Triangle</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Pascal&#8217;s triangle is a triangle of numbers computed using the following rules:
* The first row is 1.
* Each successive row is computed by adding together adjacent numbers in the row above, and adding a 1 to the beginning and end of the row.
Write a function which returns the nth row of Pascal&#8217;s Triangle.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn pascals-triangle [n]
  (last
    (take n
      (iterate
        (fn next-row [previous-row]
            (into []
                  (map (fn [e] (reduce + e))
                       (partition 2 1
                                  (conj (into [0] previous-row) 0)))))
        [1]))))

[(= (pascals-triangle 1) [1])
 (= (map pascals-triangle (range 1 6))
    [     [1]
         [1 1]
        [1 2 1]
       [1 3 3 1]
      [1 4 6 4 1]])
 (= (pascals-triangle 11)
   [1 10 45 120 210 252 210 120 45 10 1])]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_99_product_digits">99. Product Digits</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which multiplies two numbers and returns the result as a sequence of its digits.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn product-digits [a b]
  (map js/parseInt
       (str (* a b))))

[(= (product-digits 1 1) [1])
 (= (product-digits 99 9) [8 9 1])
 (= (product-digits 999 99) [9 8 9 0 1])]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_100_least_common_multiple">100. Least Common Multiple</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which calculates the least common multiple. Your function should accept a variable number of positive integers or ratios.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn least-common-multiple [&amp; n]
  (letfn [(gcd [a b]
            (if (= b 0)
              a
              (recur b (mod a b))))
          (lcm [a b]
            (/ (* a b) (gcd a b)))]
    (reduce lcm n)))

[(== (least-common-multiple 2 3) 6)
 (== (least-common-multiple 5 3 7) 105)]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_107_simple_closures">107. Simple closures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Lexical scope and first-class functions are two of the most basic building blocks of a functional language like Clojure. When you combine the two together, you get something very powerful called lexical closures. With these, you can exercise a great deal of control over the lifetime of your local bindings, saving their values for use later, long after the code you&#8217;re running now has finished. It can be hard to follow in the abstract, so let&#8217;s build a simple closure. Given a positive integer n, return a function (f x) which computes xn. Observe that the effect of this is to preserve the value of n for use outside the scope in which it is defined.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn simple-closures [n]
   (fn exp [x]
     (long (Math/pow x n))))

[(= 256 ((simple-closures 2) 16),
        ((simple-closures 8) 2))
 (= [1 8 27 64] (map (simple-closures 3) [1 2 3 4]))
 (= [1 2 4 8 16] (map #((simple-closures %) 2) [0 1 2 3 4]))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_118_re_implement_map">118. Re-implement Map</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Map is one of the core elements of a functional programming language. Given a function f and an input sequence s, return a lazy sequence of (f x) for each element x in s.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn reimplement-map [f c]
  (if (not (empty? c))
    (lazy-seq
      (cons (f (first c))
            (reimplement-map f (rest c))))))

[(= [3 4 5 6 7]
    (reimplement-map inc [2 3 4 5 6]))
 (= (repeat 10 nil)
    (reimplement-map (fn [_] nil) (range 10)))
 (= [1000000 1000001]
    (-&gt;&gt; (reimplement-map inc (range))
         (drop (dec 1000000))
         (take 2)))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_120_sum_of_square_of_digits">120. Sum of square of digits</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function which takes a collection of integers as an argument. Return the count of how many elements are smaller than the sum of their squared component digits. For example: 10 is larger than 1 squared plus 0 squared; whereas 15 is smaller than 1 squared plus 5 squared.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn sum-of-square-of-digits [c]
  (count
    (filter #(&lt; (first %) (second %))
            (map (fn [d]
                   (vector (first d)
                           (reduce + (map #(* % %) (second d)))))
                 (map (fn [e]
                        (vector e (map js/parseInt (str e))))
                      c)))))

[(= 8 (sum-of-square-of-digits (range 10)))
 (= 19 (sum-of-square-of-digits (range 30)))
 (= 50 (sum-of-square-of-digits (range 100)))
 (= 50 (sum-of-square-of-digits (range 1000)))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_122_read_a_binary_number">122. Read a binary number</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Convert a binary number, provided in the form of a string, to its numerical value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn read-a-binary-number [s]
  (int
   (reduce +
     (map-indexed #(* %2 (Math/pow 2 %1))
                  (map js/parseInt
                       (reverse s))))))

[(= 0     (read-a-binary-number "0"))
 (= 7     (read-a-binary-number "111"))
 (= 8     (read-a-binary-number "1000"))
 (= 9     (read-a-binary-number "1001"))
 (= 255   (read-a-binary-number "11111111"))
 (= 1365  (read-a-binary-number "10101010101"))
 (= 65535 (read-a-binary-number "1111111111111111"))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_128_recognize_playing_cards">128. Recognize Playing Cards</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A standard American deck of playing cards has four suits - spades, hearts, diamonds, and clubs - and thirteen cards in each suit. Two is the lowest rank, followed by other integers up to ten; then the jack, queen, king, and ace. It&#8217;s convenient for humans to represent these cards as suit/rank pairs, such as H5 or DQ: the heart five and diamond queen respectively. But these forms are not convenient for programmers, so to write a card game you need some way to parse an input string into meaningful components. For purposes of determining rank, we will define the cards to be valued from 0 (the two) to 12 (the ace). Write a function which converts (for example) the string "SJ" into a map of {:suit :spade, :rank 9}. A ten will always be represented with the single character "T", rather than the two characters "10".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn recognize-playing-cards [s]
  {:suit ({\S :spades \D :diamond \H :heart \C :club}
          (first s))
   :rank ({\2 0 \3 1 \4 2 \5 3 \6 4 \7 5 \8 6 \9 7 \T 8 \J 9 \Q 10 \K 11  \A 12}
          (second s))})

[(= {:suit :diamond :rank 10} (recognize-playing-cards "DQ"))
 (= {:suit :heart :rank 3} (recognize-playing-cards "H5"))
 (= {:suit :club :rank 12} (recognize-playing-cards "CA"))
 (= (range 13) (map (comp :rank recognize-playing-cards str)
                    '[S2 S3 S4 S5 S6 S7
                      S8 S9 ST SJ SQ SK SA]))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_135_infix_calculator">135. Infix Calculator</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Your friend Joe is always whining about Lisps using the prefix notation for math. Show him how you could easily write a function that does math using the infix notation. Is your favorite language that flexible, Joe? Write a function that accepts a variable length mathematical expression consisting of numbers and the operations +, -, *, and /. Assume a simple calculator that does not do precedence and instead just calculates left to right.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn infix-calculator [a op b &amp; more]
  (letfn [(infix [a op b] (op a b))]
  (if (zero? (count more))
      (infix a op b)
  	  (recur (infix a op b) (first more) (second more) (drop 2 more)))))

[(= 7  (infix-calculator 2 + 5))
 (= 42 (infix-calculator 38 + 48 - 2 / 2))
 (= 8  (infix-calculator 10 / 2 - 1 * 2))
 (= 72 (infix-calculator 20 / 2 + 2 + 4 + 8 - 6 - 10 * 9))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_143_dot_product">143. dot product</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create a function that computes the dot product of two sequences. You may assume that the vectors will have the same length.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn dot-product [a b]
  (reduce + (map * a b)))

[(= 0 (dot-product [0 1 0] [1 0 0]))
 (= 3 (dot-product [1 1 1] [1 1 1]))
 (= 32 (dot-product [1 2 3] [4 5 6]))
 (= 256 (dot-product [2 5 6] [100 10 1]))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_146_trees_into_tables">146. Trees into tables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Because Clojure&#8217;s for macro allows you to "walk" over multiple sequences in a nested fashion, it is excellent for transforming all sorts of sequences. If you don&#8217;t want a sequence as your final output (say you want a map), you are often still best-off using for, because you can produce a sequence and feed it into a map, for example. For this problem, your goal is to "flatten" a map of hashmaps. Each key in your output map should be the "path" that you would have to take in the original map to get to a value, so for example {1 {2 3}} should result in {[1 2] 3}. You only need to flatten one level of maps: if one of the values is a map, just leave it alone. That is, (get-in original [k1 k2]) should be the same as (get result [k1 k2])</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn trees-into-tables [m]
  (into {}
        (apply concat
               (for [[k v] m]
                 (map #(vector [k (first %)] (second %)) v)))))

[(= (trees-into-tables '{a {p 1, q 2}
                         b {m 3, n 4}})
    '{[a p] 1, [a q] 2
      [b m] 3, [b n] 4})
 (= (trees-into-tables '{[1] {a b c d}
                         [2] {q r s t u v w x}})
   '{[[1] a] b, [[1] c] d,
     [[2] q] r, [[2] s] t,
     [[2] u] v, [[2] w] x})
 (= (trees-into-tables '{m {1 [a b c] 3 nil}})
                       '{[m 1] [a b c], [m 3] nil})]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_147_pascal_s_trapezoid">147. Pascal&#8217;s Trapezoid</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Write a function that, for any given input vector of numbers, returns an infinite lazy sequence of vectors, where each next one is constructed from the previous following the rules used in Pascal&#8217;s Triangle. For example, for [3 1 2], the next row is [3 4 3 2]. Beware of arithmetic overflow! In clojure (since version 1.3 in 2011), if you use an arithmetic operator like + and the result is too large to fit into a 64-bit integer, an exception is thrown. You can use +' to indicate that you would rather overflow into Clojure&#8217;s slower, arbitrary-precision bigint.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn pascals-trapezoid [row]
  (iterate
    (fn next-row [previous-row]
      (into []
            (map (fn [e] (reduce + e))
                 (partition 2 1
                            (conj (into [0] previous-row) 0)))))
    row))

[(= (second (pascals-trapezoid [2 3 2])) [2 5 5 2])
 (= (take 5 (pascals-trapezoid [1])) [[1] [1 1] [1 2 1] [1 3 3 1] [1 4 6 4 1]])
 (= (take 2 (pascals-trapezoid [3 1 2])) [[3 1 2] [3 4 3 2]])
 (= (take 100 (pascals-trapezoid [2 4 2])) (rest (take 101 (pascals-trapezoid [2 2]))))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_153_pairwise_disjoint_sets">153. Pairwise Disjoint Sets</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Given a set of sets, create a function which returns true if no two of those sets have any elements in common and false otherwise. Some of the test cases are a bit tricky, so pay a little more attention to them. Such sets are usually called pairwise disjoint or mutually disjoint.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn pairwise-disjoint-sets [s]
  (=
    (count
      (apply concat '() s))
    (count
      (apply clojure.set/union s))))

[(= (pairwise-disjoint-sets #{#{\U} #{\s} #{\e \R \E} #{\P \L} #{\.}})
    true)
 (= (pairwise-disjoint-sets #{#{:a :b :c :d :e}
                            #{:a :b :c :d}
                            #{:a :b :c}
                            #{:a :b}
                            #{:a}})
    false)
 (= (pairwise-disjoint-sets #{#{[1 2 3] [4 5]}
                              #{[1 2] [3 4 5]}
                              #{[1] [2] 3 4 5}
                              #{1 2 [3 4] [5]}})
    true)
 (= (pairwise-disjoint-sets #{#{'a 'b}
                              #{'c 'd 'e}
                              #{'f 'g 'h 'i}
                              #{''a ''c ''f}})
    true)
 (= (pairwise-disjoint-sets #{#{'(:x :y :z) '(:x :y) '(:z) '()}
                              #{#{:x :y :z} #{:x :y} #{:z} #{}}
                              #{'[:x :y :z] [:x :y] [:z] [] {}}})
    false)
 (= (pairwise-disjoint-sets #{#{(= "true") false}
                              #{:yes :no}
                              #{(symbol "true") 'false}
                              #{(keyword "yes") ::no}})
    false)
 (= (pairwise-disjoint-sets #{#{distinct?}
                              #{#(-&gt; %) #(-&gt; %)}
                              #{#(-&gt; %) #(-&gt; %) #(-&gt; %)}
                              #{#(-&gt; %) #(-&gt; %) #(-&gt; %)}})
    true)
 (= (pairwise-disjoint-sets #{#{(#(-&gt; *)) + (quote mapcat) #_ nil}
                             #{'+ '* mapcat (comment mapcat)}
                             #{(do) set contains? nil?}
                             #{, , , #_, , empty?}})
    false)]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_157_indexing_sequences">157. Indexing Sequences</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Transform a sequence into a sequence of pairs containing the original elements along with their index.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn indexing-sequences [s]
  (map-indexed (fn [index element] [element index]) s))

[(= (indexing-sequences [:a :b :c]) [[:a 0] [:b 1] [:c 2]])
 (= (indexing-sequences [0 1 3]) '((0 0) (1 1) (3 2)))
 (= (indexing-sequences [[:foo] {:bar :baz}]) [[[:foo] 0] [{:bar :baz} 1]])]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_166_comparisons">166. Comparisons</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For any orderable data type it&#8217;s possible to derive all of the basic comparison operations (&lt;, ≤, =, ≠, ≥, and &gt;) from a single operation (any operator but = or ≠ will work). Write a function that takes three arguments, a less than operator for the data and two items to compare. The function should return a keyword describing the relationship between the two items. The keywords for the relationship between x and y are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>x = y → :eq</p>
</li>
<li>
<p>x &gt; y → :gt</p>
</li>
<li>
<p>x &lt; y → :lt</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">(defn comparisons [f l r]
  (cond
    (= (f l r) (f r l)) :eq
    (f l r) :lt
    :else :gt))

[(= :gt (comparisons &lt; 5 1))
 (= :eq (comparisons (fn [x y] (&lt; (count x) (count y))) "pear" "plum"))
 (= :lt (comparisons (fn [x y] (&lt; (mod x 5) (mod y 5))) 21 3))
 (= :gt (comparisons &gt; 0 2))]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_173_intro_to_destructuring_2">173. Intro to Destructuring 2</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sequential destructuring allows you to bind symbols to parts of sequential things (vectors, lists, seqs, etc.): (let [bindings* ] exprs*) Complete the bindings so all let-parts evaluate to 3.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-klipse" data-lang="klipse">[(= 3
   (let [[f x] [+ (range 3)]] (apply f x))
   (let [[[f x] b] [[+ 1] 2]] (f x b))
   (let [[f x] [inc 2]] (f x)))]</code></pre>
</div>
</div>
</div>
</div>


    <div class="post-footer">
      

    
    
    
    
      
      
      
        
      
    
      
      
      
        
      
    
      
      
      
        
      
    
      
      
      
        
      
    
      
      
      
        
      
    
      
      
      
        
      
    
      
      
      
        
      
    
      
      
      
        
      
    
      
      
      
        
      
    
      
      
      
        
      
    
      
      
      
    
      
      
      
        
      
    
      
      
      
    
      
      
      
    
      
      
      
        
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    
      
      
      
    

    <h1>See also</h1>
      <div class="paragraph">
        <ul>
        
          
          
          
            <li><a href="https://www.anthony-galea.com/blog/post/how-many-eggs-should-a-woodchuck-chuck/">How many eggs should a woodchuck chuck?</a> <a class="label" href="https://www.anthony-galea.com/categories/clojure">clojure</a><a class="label" href="https://www.anthony-galea.com/categories/interactive">interactive</a></li>
          
        
          
          
          
            <li><a href="https://www.anthony-galea.com/blog/post/modeling-big-two/">Modeling Big two</a> <a class="label" href="https://www.anthony-galea.com/categories/clojure">clojure</a><a class="label" href="https://www.anthony-galea.com/categories/interactive">interactive</a></li>
          
        
          
          
          
            <li><a href="https://www.anthony-galea.com/blog/post/visualizing-the-prisoners-dilemma/">Visualizing the Prisoner&#39;s Dilemma</a> <a class="label" href="https://www.anthony-galea.com/categories/clojure">clojure</a><a class="label" href="https://www.anthony-galea.com/categories/interactive">interactive</a></li>
          
        
          
          
          
            <li><a href="https://www.anthony-galea.com/blog/post/iterated-function-systems/">Iterated Function Systems</a> <a class="label" href="https://www.anthony-galea.com/categories/clojure">clojure</a><a class="label" href="https://www.anthony-galea.com/categories/interactive">interactive</a></li>
          
        
          
          
          
            <li><a href="https://www.anthony-galea.com/blog/post/the-template-method-pattern/">The Template Method Pattern</a> <a class="label" href="https://www.anthony-galea.com/categories/design-patterns">design-patterns</a><a class="label" href="https://www.anthony-galea.com/categories/java">java</a><a class="label" href="https://www.anthony-galea.com/categories/scala">scala</a><a class="label" href="https://www.anthony-galea.com/categories/kotlin">kotlin</a><a class="label" href="https://www.anthony-galea.com/categories/clojure">clojure</a></li>
          
        
          
          
          
            <li><a href="https://www.anthony-galea.com/blog/post/4clojure-solutions-over-time/">4Clojure solutions over time</a> <a class="label" href="https://www.anthony-galea.com/categories/clojure">clojure</a></li>
          
        
          
          
          
            <li><a href="https://www.anthony-galea.com/blog/post/hello-parking-garage-meet-clojure.spec/">Hello parking garage, meet clojure.spec</a> <a class="label" href="https://www.anthony-galea.com/categories/clojure">clojure</a></li>
          
        
          
          
          
            <li><a href="https://www.anthony-galea.com/blog/post/simulating-a-parking-garage-with-clojure-refs/">Simulating a parking garage with Clojure Refs</a> <a class="label" href="https://www.anthony-galea.com/categories/clojure">clojure</a></li>
          
        
          
          
          
            <li><a href="https://www.anthony-galea.com/blog/post/using-datomic-in-a-simple-use-case/">Using Datomic in a simple use case</a> <a class="label" href="https://www.anthony-galea.com/categories/clojure">clojure</a></li>
          
        
          
          
          
            <li><a href="https://www.anthony-galea.com/blog/post/solutions-to-4clojure-medium-problems/">Solutions to 4Clojure Medium Problems</a> <a class="label" href="https://www.anthony-galea.com/categories/clojure">clojure</a><a class="label" href="https://www.anthony-galea.com/categories/interactive">interactive</a></li>
          
        
          
          
          
        
          
          
          
            <li><a href="https://www.anthony-galea.com/blog/post/getting-started-with-compojure-api/">Getting started with compojure-api</a> <a class="label" href="https://www.anthony-galea.com/categories/clojure">clojure</a></li>
          
        
          
          
          
        
          
          
          
        
          
          
          
            <li><a href="https://www.anthony-galea.com/blog/post/solutions-to-4clojure-elementary-problems/">Solutions to 4Clojure Elementary Problems</a> <a class="label" href="https://www.anthony-galea.com/categories/clojure">clojure</a><a class="label" href="https://www.anthony-galea.com/categories/interactive">interactive</a></li>
          
        
          
          
          
        
          
          
          
        
          
          
          
        
          
          
          
        
          
          
          
        
          
          
          
        
          
          
          
        
          
          
          
        
          
          
          
        
          
          
          
        
          
          
          
        
          
          
          
        
          
          
          
        
          
          
          
        
          
          
          
        
          
          
          
        
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
            <li><a href="https://www.anthony-galea.com/blog/post/how-to-fail-at-almost-everything-and-still-win-big---scott-adams/">How to Fail at Almost Everything and Still Win Big - Scott Adams</a> <a class="label" href="https://www.anthony-galea.com/categories/book-notes">book-notes</a></li>
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
            <li><a href="https://www.anthony-galea.com/blog/post/an-astronauts-guide-to-life-on-earth---christian-hadfield/">An Astronaut&#39;s Guide to Life on Earth - Christian Hadfield</a> <a class="label" href="https://www.anthony-galea.com/categories/book-notes">book-notes</a></li>
            
        
            
            
            
            
        
            
            
            
            
            <li><a href="https://www.anthony-galea.com/blog/post/better-apis-with-java-optional/">Better APIs with Java Optional</a> <a class="label" href="https://www.anthony-galea.com/categories/java">java</a><a class="label" href="https://www.anthony-galea.com/categories/groovy">groovy</a></li>
            
        
            
            
            
            
            <li><a href="https://www.anthony-galea.com/blog/post/the-builder-pattern-in-java/">The Builder Pattern in Java</a> <a class="label" href="https://www.anthony-galea.com/categories/design-patterns">design-patterns</a><a class="label" href="https://www.anthony-galea.com/categories/java">java</a></li>
            
        
            
            
            
            
            <li><a href="https://www.anthony-galea.com/blog/post/an-introduction-to-load-testing-with-gatling/">An Introduction to Load Testing with Gatling</a> <a class="label" href="https://www.anthony-galea.com/categories/testing">testing</a><a class="label" href="https://www.anthony-galea.com/categories/http">http</a><a class="label" href="https://www.anthony-galea.com/categories/scala">scala</a></li>
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
            
            
            
            
        
        </ul>
    </div>
    </div>
  
  

</div>




</div>


<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.29.0/codemirror.min.css">
<link rel="stylesheet" href='https://fonts.googleapis.com/css?family=Lato' type='text/css'>
<link rel="stylesheet" href="https://www.anthony-galea.com/css/below-the-fold.min.css">

<script>
 window.klipse_settings = {
     selector: '.language-klipse',
     codemirror_options_in: {
         indentUnit: 2,
         lineWrapping: true,
         lineNumbers: true,
         autoCloseBrackets: true
     }
 };
</script>
<script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML" type="text/javascript"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
});
</script>
</body>
</html>

